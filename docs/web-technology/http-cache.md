# 什么是 http 缓存？

前端页面发送请求获取服务器数据是很常见的操作，如果请求相同资源的次数不止一次，便会造成网络资源的浪费和用户的体验下降，所以需要合理的使用缓存技术对已请求资源进行重用

缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。

http 缓存可细分为**强制缓存**和**协商缓存**，区别在于浏览器判断缓存命中时，是否需要向服务器进行询问，进而判断是否需要重新请求。

## 强制缓存

> 对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无须与服务器进行任何通信。

### 1.Expires (http1.0)

```http
Expires: Web, 14 Fed 2021 12:23:42 GMT
```

**`Expires`**  响应标头包含响应应被视为过期的日期/时间。

缺陷在于 Expires 过分依赖本地时间，当本地时间和客户端时间不同步时，判断便不能达到预期效果。

如果响应中有指令为  `max-age`  或  `s-maxage`  的  Cache-Control  标头，则  `Expires`  标头会被忽略。

### 2.Cache-Control (http1.1)

**`Cache-Control`**  通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。

#### 禁止缓存

发送如下响应头可以关闭缓存

```http
Cache-Control: no-store
```

#### 缓存静态资源

对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和 JavaScript 文件。

```http
Cache-Control:public, max-age=31536000
```

#### 需要重新验证

指定  `no-cache`  或  `max-age=0, must-revalidate`  表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。

```http
Cache-Control: no-cache
```

```http
Cache-Control: max-age=0, must-revalidate
```

> **注意**: 如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。

```http
Cache-Control: max-age=0
```

---

## 协商缓存

> 协商缓存就是在使用本地缓存之前，需要向服务器端发起一次 GET 请求，与之协商当前浏览器保存的本地缓存是否已经过期。

### 1.Last-Modified (http1.0)

**`Last-Modified`**  是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比  `ETag`  要低，所以这是一个备用机制。包含有  `If-Modified-Since`  或  `If-Unmodified-Since`  首部的条件请求会使用这个字段。

请求示例如下 `test.js`

```http
请求字段
Request-URL: http://localhost:3000/test.js
Request-Method: GET
响应字段
Last-Modified: Thu, 29 Apr 2021 03:09:28 GMT
Cache-Control: no-cache
```

当我们刷新网页时，由于该 JavaScript 文件使用的是协商缓存，客户端浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次 GET 请求，进行缓存有效性的协商，此次 GET 请求的请求头中需要包含一个 If-Modified-Since 字段，其值正是上次响应头中 `Last-Modified` 的字段值。

```http
请求字段
Request-URL: http://localhost:3000/test.js
Request-Method: GET
If-Modified-Since: Thu, 29 Apr 2021 03:09:28 GMT
响应字段
Status-Code: 304 Not Modified
```

**注意**：协商缓存判断缓存有效的响应状态码是 **304** ，即缓存有效响应重定向到本地缓存上。这和强制缓存有所不同，强制缓存若有效，则再次请求的响应状态码是 **200**。

#### 不足

-   首先它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。
-   其次标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。

### 2.ETag (http1.1)

**`ETag`** HTTP 响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web 服务器不需要发送完整的响应。而如果内容发生了变化，使用 ETag 有助于防止资源的同时更新相互覆盖（“空中碰撞”）。

如果给定 URL 中的资源更改，则*一定*要生成新的  `ETag`  值。比较这些  `ETag`  能快速确定此资源是否变化。

示例如下：

```http
响应字段
Content-Type: image/jpeg
ETag: "xxx" Last-Modified: Fri, 12 Jul 2021 18:30:00 GMT
Content-Length: 9887
```

上述响应头中同时包含了 **Last-Modified** 文件修改时间戳和 **ETag** 实体标签两种协商缓存的有效性校验字段，因为 **ETag** 比 **Last-Modified** 具有更准确的文件资源变化感知，所以它的优先级也更高，二者同时存在时以 **ETag** 为准。

再次对该图片资源发起请求时，会将之前响应头中 **ETag** 的字段值作为此次请求头中 **If-None-Match** 字段，提供给服务器进行缓存有效性验证。请求头与响应头的关键字段信息如下。

再次请求头：

```http
再次请求字段
If-Modified-Since: Fri, 12 Jul 2021 18:30:00 GMT
If-None-Match: "xxx"
再次响应字段
Content-Type: image/jpeg ETag: "xxx"
Last-Modified: Fri, 12 Jul 2021 18:30:00 GMT
Content-Length: 9887
```

若验证缓存有效，则返回 **304** 状态码响应重定向到本地缓存，所以上面响应头中的内容长度 **Content-Length** 字段值也就为 0 了。

#### 不足

不像强制缓存中 Cache-Control 可以完全替代 Expires 的功能，在协商缓存中，ETag 并非 **Last-Modified** 的替代方案而是一种补充方案，因为它依旧存在一些弊端。

-   一方面服务器对于生成文件资源的 **ETag** 需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成 ETag 的过程就会影响服务器的性能。
-   另一方面 **ETag** 字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同；弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。

## 缓存决策

思考一下如何应用 HTTP 缓存技术来提升网站的性能。假设在不考虑客户端缓存容量与服务器算力的理想情况下，我们当然希望客户端浏览器上的缓存触发率尽可能高，留存时间尽可能长，同时还要 **ETag** 实现当资源更新时进行高效的重新验证。

但实际情况往往是容量与算力都有限，因此就需要制定合适的缓存策略，来利用有限的资源达到最优的性能效果。明确能力的边界，力求在边界内做到最好。

### 缓存决策树

在面对一个具体的缓存需求时，到底该如何制定缓存策略呢？我们可以参照图所示的决策树来逐步确定对一个资源具体的缓存策略。

<img title="" src="/assets/http-cache.jpg" style="zoom:33%;">

### 缓存决策示例

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HTTP 缓存策略</title>
        <link rel="stylesheet" href="style.css" />
    </head>
    <body>
        <img src="photo.jpg" alt="poto" />
        <script src="script.js"></script>
    </body>
</html>
```

首先 HTML 在这里属于包含其他文件的主文件，为保证当其内容发生修改时能及时更新，应当将其设置为协商缓存，即为 **Cache-Control：no-cache** ; 其次是图片文件，因为网站对图片的修改基本都是更换修改，同时考虑到图片文件的数量及大小可能对客户端缓存空间造成不小的开销，所以可采用强制缓存且过期时间不宜过长，故可设置 **Cache-Control：max-age=86400**。

接下来需要考虑的是样式表文件 **style.css**，由于其属于文本文件，可能存在内容的不定期修改，又想使用强制缓存来提高重用效率，故可以考虑在样式表文件的命名中增加文件指纹或版本号（比如添加文件指纹后的样式表文件名变为了 **style.51ad84f7.css**），这样当发生文件修改后，不同的文件便会有不同的文件指纹，即需要请求的文件 URL 不同了，因此必然会发生对资源的重新请求。同时考虑到网络中浏览器与 CDN 等中间代理的缓存，其过期时间可适当延长到一年，即 **Cache-Control：max-age=31536000**

最后是 JavaScript 脚本文件，其可类似于样式表文件的设置，采取文件指纹和较长的过期时间，如果 JavaScript 中包含了用户的私人信息而不想让中间代理缓存，则可为 **Cache-Control** 添加 **private** 属性值。

### 缓存设置注意事项

在前面的内容中虽然给出了一种制定缓存决策的思路与示例，但需要明白的一点是：不存在适用于所有场景下的最佳缓存策略。凡是恰当的缓存策略都需要根据具体场景下的请求资源类型、数据更新要求及网络通信模式等多方面因素考量后制定出来，所以下面列举一些缓存决策时的注意事项，来作为决策思路的补充。

1. 拆分源码，分包加载
   对大型的前端应用迭代开发来说，其代码量通常很大，如果发生修改的部分集中在几个重要模块中，那么进行全量的代码更新显然会比较冗余，因此我们可以考虑在代码构建过程中，按照模块拆分将其打包成多个单独的文件。这样在每次修改后的更新提取时，仅需拉取发生修改的模块代码包，从而大大降低了需要下载的内容大小。
2. 预估资源的缓存时效
   根据不同资源的不同需求特点，规划相应的缓存更新时效，为强制缓存指定合适的 **max-age** 取值，为协商缓存提供验证更新的 **ETag** 实体标签。
3. 控制中间代理的缓存
   凡是会涉及用户隐私信息的尽量避免中间代理的缓存，如果对所有用户响应相同的资源，则可以考虑让中间代理也进行缓存。
4. 避免网址的冗余
   缓存是根据请求资源的 URL 进行的，不同的资源会有不同的 URL，所以尽量不要将相同的资源设置为不同的 URL。
5. 规划缓存的层次结构
   参考缓存决策中介绍的示例，不仅是请求的资源类型，文件资源的层次结构也会对制定缓存策略有一定影响，我们应当综合考虑。
